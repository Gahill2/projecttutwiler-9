from typing import Dict, List, Any, Optional
from datetime import datetime
import re

def normalize_nvd(cve_item: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize NVD CVE item to common schema"""
    cve_id = cve_item.get("id", "")
    
    # Extract CVSS scores
    cvss = {}
    metrics = cve_item.get("metrics", {})
    
    # CVSS v3.1
    if "cvssMetricV31" in metrics and len(metrics["cvssMetricV31"]) > 0:
        v31 = metrics["cvssMetricV31"][0]
        cvss["v31"] = v31.get("cvssData", {}).get("baseScore", 0.0)
        cvss["vector"] = v31.get("cvssData", {}).get("vectorString", "")
    # CVSS v3.0 fallback
    elif "cvssMetricV30" in metrics and len(metrics["cvssMetricV30"]) > 0:
        v30 = metrics["cvssMetricV30"][0]
        cvss["v30"] = v30.get("cvssData", {}).get("baseScore", 0.0)
        cvss["vector"] = v30.get("cvssData", {}).get("vectorString", "")
    # CVSS v2 fallback
    elif "cvssMetricV2" in metrics and len(metrics["cvssMetricV2"]) > 0:
        v2 = metrics["cvssMetricV2"][0]
        cvss["v2"] = v2.get("cvssData", {}).get("baseScore", 0.0)
        cvss["vector"] = v2.get("cvssData", {}).get("vectorString", "")
    
    # Extract CWE
    cwe_list = []
    weaknesses = cve_item.get("weaknesses", [])
    for weakness in weaknesses:
        for desc in weakness.get("description", []):
            cwe_id = desc.get("value", "")
            if cwe_id.startswith("CWE-"):
                cwe_list.append(cwe_id)
    
    # Extract references
    refs = []
    references = cve_item.get("references", [])
    for ref in references:
        url = ref.get("url", "")
        if url:
            refs.append(url)
    
    # Extract vendor/products
    vendor_products = []
    configurations = cve_item.get("configurations", [])
    for config in configurations:
        nodes = config.get("nodes", [])
        for node in nodes:
            for cpe_match in node.get("cpeMatch", []):
                cpe = cpe_match.get("criteria", "")
                if cpe:
                    # Parse CPE: cpe:2.3:a:vendor:product:version
                    parts = cpe.split(":")
                    if len(parts) >= 5:
                        vendor = parts[3]
                        product = parts[4]
                        if vendor and product and vendor != "*" and product != "*":
                            vendor_products.append(f"{vendor}:{product}")
    
    # Get descriptions
    descriptions = cve_item.get("descriptions", [])
    title = ""
    summary = ""
    for desc in descriptions:
        if desc.get("lang") == "en":
            if desc.get("type") == "Primary":
                summary = desc.get("value", "")
            else:
                title = desc.get("value", "")[:200]  # Truncate title
    
    if not title:
        title = summary[:200] if summary else cve_id
    
    # Determine severity from CVSS
    severity = "UNKNOWN"
    if "v31" in cvss:
        score = cvss["v31"]
    elif "v30" in cvss:
        score = cvss["v30"]
    elif "v2" in cvss:
        score = cvss["v2"]
    else:
        score = 0.0
    
    if score >= 9.0:
        severity = "CRITICAL"
    elif score >= 7.0:
        severity = "HIGH"
    elif score >= 4.0:
        severity = "MEDIUM"
    elif score > 0.0:
        severity = "LOW"
    
    # Parse dates
    published = cve_item.get("published", "")
    modified = cve_item.get("lastModified", "")
    
    return {
        "id": cve_id,
        "source": "nvd",
        "title": title,
        "summary": summary,
        "cwe": list(set(cwe_list)),  # Deduplicate
        "cvss": cvss,
        "published": published,
        "modified": modified,
        "refs": refs,
        "vendor_products": list(set(vendor_products)),  # Deduplicate
        "severity": severity
    }

def normalize_cisa_kev(kev_item: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize CISA KEV item to common schema"""
    cve_id = kev_item.get("cveID", "")
    title = kev_item.get("vulnerabilityName", "")
    summary = kev_item.get("shortDescription", "") or title
    
    # CISA KEV doesn't provide CVSS, but all are known exploited
    cvss = {}
    severity = "CRITICAL"  # KEV items are by definition critical
    
    # Extract vendor/product
    vendor_products = []
    vendor = kev_item.get("vendorProject", "")
    product = kev_item.get("product", "")
    if vendor and product:
        vendor_products.append(f"{vendor.lower()}:{product.lower()}")
    
    # Parse dates
    published = kev_item.get("dateAdded", "")
    modified = kev_item.get("dateAdded", "")  # KEV doesn't track modifications
    
    # References
    refs = []
    if kev_item.get("requiredAction"):
        refs.append(f"Required Action: {kev_item['requiredAction']}")
    
    return {
        "id": cve_id,
        "source": "cisa_kev",
        "title": title,
        "summary": summary,
        "cwe": [],  # CISA KEV doesn't provide CWE
        "cvss": cvss,
        "published": published,
        "modified": modified,
        "refs": refs,
        "vendor_products": vendor_products,
        "severity": severity
    }

def normalize_osv(osv_item: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize OSV item to common schema"""
    cve_id = ""
    for alias in osv_item.get("aliases", []):
        if alias.startswith("CVE-"):
            cve_id = alias
            break
    
    if not cve_id:
        cve_id = osv_item.get("id", "")
    
    summary = osv_item.get("summary", "")
    title = summary[:200] if summary else cve_id
    
    # Extract severity from database_specific
    severity = "UNKNOWN"
    db_specific = osv_item.get("database_specific", {})
    if "severity" in db_specific:
        sev = db_specific["severity"].upper()
        if sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            severity = sev
    
    # Extract CVSS if available
    cvss = {}
    if "cvss_score" in db_specific:
        cvss["score"] = db_specific["cvss_score"]
    
    # Extract CWE
    cwe_list = []
    if "cwe" in db_specific:
        cwe = db_specific["cwe"]
        if isinstance(cwe, str) and cwe.startswith("CWE-"):
            cwe_list.append(cwe)
        elif isinstance(cwe, list):
            for c in cwe:
                if isinstance(c, str) and c.startswith("CWE-"):
                    cwe_list.append(c)
    
    # Extract references
    refs = []
    for ref in osv_item.get("references", []):
        url = ref.get("url", "")
        if url:
            refs.append(url)
    
    # Extract vendor/products from affected packages
    vendor_products = []
    for affected in osv_item.get("affected", []):
        package = affected.get("package", {})
        ecosystem = package.get("ecosystem", "")
        name = package.get("name", "")
        if ecosystem and name:
            vendor_products.append(f"{ecosystem}:{name}")
    
    # Parse dates
    published = osv_item.get("published", "")
    modified = osv_item.get("modified", "") or published
    
    return {
        "id": cve_id,
        "source": "osv",
        "title": title,
        "summary": summary,
        "cwe": cwe_list,
        "cvss": cvss,
        "published": published,
        "modified": modified,
        "refs": refs,
        "vendor_products": vendor_products,
        "severity": severity
    }

def build_embedding_text(normalized: Dict[str, Any]) -> str:
    """Build clean text for embedding from normalized CVE"""
    parts = []
    
    # Title and summary
    if normalized.get("title"):
        parts.append(normalized["title"])
    if normalized.get("summary"):
        parts.append(normalized["summary"])
    
    # CWE
    if normalized.get("cwe"):
        parts.append("CWE: " + ", ".join(normalized["cwe"]))
    
    # Severity
    if normalized.get("severity"):
        parts.append(f"Severity: {normalized['severity']}")
    
    # Reference domains (extract domains from URLs)
    if normalized.get("refs"):
        domains = set()
        for ref in normalized["refs"]:
            if ref.startswith("http://") or ref.startswith("https://"):
                try:
                    from urllib.parse import urlparse
                    domain = urlparse(ref).netloc
                    if domain:
                        domains.add(domain)
                except:
                    pass
        if domains:
            parts.append("References: " + ", ".join(sorted(domains)))
    
    return " ".join(parts)

def chunk_text(text: str, chunk_size: int = 600) -> List[str]:
    """Simple chunking by approximate token count (characters / 4)"""
    # Rough estimate: 1 token â‰ˆ 4 characters
    char_limit = chunk_size * 4
    chunks = []
    
    for i in range(0, len(text), char_limit):
        chunk = text[i:i + char_limit]
        chunks.append(chunk)
    
    return chunks

