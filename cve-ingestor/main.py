import os
from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse
from typing import Optional
from ingest import refresh_all, get_stats, fetch_nvd, fetch_cisa_kev
from scheduler import start_scheduler, stop_scheduler

# Initialize Sentry if DSN is provided
def init_sentry(service_name: str):
    """Initialize Sentry if DSN is provided"""
    sentry_dsn = os.getenv("SENTRY_DSN")
    if not sentry_dsn:
        return None
    
    try:
        import sentry_sdk
        from sentry_sdk.integrations.fastapi import FastApiIntegration
        from sentry_sdk.integrations.logging import LoggingIntegration
        
        sentry_sdk.init(
            dsn=sentry_dsn,
            integrations=[
                FastApiIntegration(),
                LoggingIntegration(level=None, event_level=None),
            ],
            traces_sample_rate=1.0,
            environment=os.getenv("APP_ENV", "dev"),
            release=os.getenv("GIT_SHA"),
        )
        
        sentry_sdk.set_tag("service", service_name)
        return sentry_sdk
    except ImportError:
        return None

# Initialize Sentry if DSN is provided
init_sentry("cve-ingestor")

app = FastAPI(title="CVE Ingestor")

@app.on_event("startup")
async def startup_event():
    """Start background scheduler on startup"""
    start_scheduler()

@app.on_event("shutdown")
async def shutdown_event():
    """Stop background scheduler on shutdown"""
    stop_scheduler()

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.get("/stats")
async def stats():
    """Get ingestion stats per namespace"""
    return {"namespaces": get_stats()}

@app.post("/refresh")
async def refresh():
    """Manually trigger refresh of all CVE sources"""
    try:
        results = refresh_all()
        return {
            "status": "success",
            "results": results
        }
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"status": "error", "error": str(e)}
        )

@app.get("/cves/recent")
async def get_recent_cves(
    days: int = Query(7, ge=1, le=30, description="Number of days to look back"),
    limit: int = Query(50, ge=1, le=500, description="Maximum number of CVEs to return"),
    source: Optional[str] = Query(None, description="Source filter: 'nvd', 'cisa_kev', or None for both")
):
    """Fetch recent CVEs without ingesting them. Useful for displaying common/recent CVEs."""
    try:
        results = []
        
        # Fetch from NVD if source is None or 'nvd'
        if source is None or source == "nvd":
            api_key = os.getenv("NVD_API_KEY") or None
            nvd_cves = fetch_nvd(window_days=days, api_key=api_key)
            for cve in nvd_cves[:limit]:
                cve_id = cve.get("id", "UNKNOWN")
                descriptions = cve.get("descriptions", [])
                description = next((d.get("value", "") for d in descriptions if d.get("lang") == "en"), "")
                
                # Get CVSS score if available
                metrics = cve.get("metrics", {})
                cvss_v3 = metrics.get("cvssMetricV31", [{}])[0] if metrics.get("cvssMetricV31") else {}
                cvss_v2 = metrics.get("cvssMetricV2", [{}])[0] if metrics.get("cvssMetricV2") else {}
                base_score = cvss_v3.get("cvssData", {}).get("baseScore") or cvss_v2.get("cvssData", {}).get("baseScore")
                
                results.append({
                    "id": cve_id,
                    "source": "nvd",
                    "description": description[:500],  # Truncate long descriptions
                    "base_score": base_score,
                    "published": cve.get("published", ""),
                })
        
        # Fetch from CISA KEV if source is None or 'cisa_kev'
        if source is None or source == "cisa_kev":
            cisa_kevs = fetch_cisa_kev()
            for kev in cisa_kevs[:limit]:
                results.append({
                    "id": kev.get("cveID", "UNKNOWN"),
                    "source": "cisa_kev",
                    "description": kev.get("vulnerabilityName", ""),
                    "base_score": None,
                    "published": kev.get("dateAdded", ""),
                    "known_exploited": True,
                })
        
        # Sort by published date (most recent first) and limit
        results.sort(key=lambda x: x.get("published", ""), reverse=True)
        results = results[:limit]
        
        return {
            "status": "success",
            "count": len(results),
            "cves": results
        }
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"status": "error", "error": str(e)}
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=9095)

